"""Helper functions for processing and manipulating response content and environment.

This module contains utility functions designed to assist in the handling and
modification of response content generated by the language model, as well as
functions for managing the execution environment. These functions are crucial
for maintaining the integrity and usability of the responses and ensuring proper
setup for subprocess execution.
"""

import json
import logging
import os
import platform
import re
import subprocess


def remove_think_tags(response_content: str) -> str:
    """
    Remove the content enclosed within <think> and </think> tags from the response content.

    Args:
        response_content (str): The original response content potentially containing <think> tags.

    Returns:
        str: The response content with <think> and </think> tags and their content removed.
    """
    if "<think>" in response_content:
        start_think_index = response_content.find("<think>")
        end_think_index = response_content.rfind("</think>")
        if start_think_index != -1 and end_think_index != -1:
            response_content = (
                response_content[:start_think_index]
                + response_content[end_think_index + len("</think>") :].strip()
            )
    return response_content


def clean_plain_text_response(response_content: str) -> str:
    """
    Clean plain text responses like reflection and planning by removing code blocks and
    standalone JSON.

    Args:
        response_content (str): The original plain text response potentially containing
                               code blocks or JSON objects.

    Returns:
        str: The cleaned response with code blocks and standalone JSON removed.
    """
    # Check if the entire content is a JSON object
    if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
        try:
            json.loads(response_content.strip())
            # If it parses as valid JSON, remove it completely
            return ""
        except json.JSONDecodeError:
            # Not valid JSON, keep the content
            pass

    # Remove code blocks
    lines = response_content.split("\n")
    cleaned_lines = []
    in_code_block = False
    code_block_start_index = -1

    for i, line in enumerate(lines):
        if line.strip().startswith("```"):
            if not in_code_block:
                in_code_block = True
                code_block_start_index = i
            else:
                in_code_block = False
                # Add an empty line if there's content before and after the code block
                if code_block_start_index > 0 and i < len(lines) - 1:
                    cleaned_lines.append("")
            continue
        if not in_code_block:
            cleaned_lines.append(line.rstrip())

    cleaned_content = "\n".join(cleaned_lines)

    # Remove JSON objects embedded in the text
    pattern = r'\{(?:[^{}]|"[^"]*")*\}'
    cleaned_content = re.sub(pattern, "", cleaned_content)

    # Clean up any double spaces and preserve line breaks
    cleaned_content = re.sub(r" +", " ", cleaned_content)

    # Remove trailing spaces at the end of each line and leading spaces at the beginning
    # of each line
    cleaned_content = "\n".join(line.strip() for line in cleaned_content.split("\n"))

    return cleaned_content.strip()


def clean_json_response(response_content: str) -> str:
    """
    Clean JSON responses by extracting the JSON content from various formats.

    Args:
        response_content (str): The original JSON response potentially containing
                               code blocks, markdown formatting, or other text.

    Returns:
        str: The extracted JSON content as a string.
    """
    response_content = remove_think_tags(response_content)

    # Special case for the format: ```json\n{...}\n```
    start = response_content.strip().startswith("```json")
    end = response_content.strip().endswith("```")
    if start and end:
        start_marker = "```json\n"
        if start_marker in response_content:
            start_idx = response_content.find(start_marker) + len(start_marker)
            end_idx = response_content.rfind("\n```")
            if end_idx != -1 and end_idx > start_idx:
                result = response_content[start_idx:end_idx].strip()
                if result.endswith("}"):
                    return result

    # Check if the entire content is already valid JSON
    try:
        if response_content.strip().startswith("{") and response_content.strip().endswith("}"):
            json.loads(response_content.strip())
            return response_content.strip()
    except json.JSONDecodeError:
        pass

    # Always search for JSON in code blocks regardless of leading text
    json_block_marker = "```json\n"
    if json_block_marker in response_content:
        start_index = response_content.find(json_block_marker) + len(json_block_marker)
        end_marker = "\n```"
        end_index = response_content.find(end_marker, start_index)

        if end_index != -1:
            json_content = response_content[start_index:end_index].strip()

            # Check for a complete JSON object
            if json_content.startswith("{") and json_content.endswith("}"):
                try:
                    json.loads(json_content)
                    return json_content
                except json.JSONDecodeError:
                    pass

            # If full content isn't parseable, try to extract the JSON object
            first_brace = json_content.find("{")
            last_brace = json_content.rfind("}")

            if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                extracted_json = json_content[first_brace : last_brace + 1]
                try:
                    json.loads(extracted_json)
                    return extracted_json
                except json.JSONDecodeError:
                    pass

    # Check for JSON code block format with triple backticks
    is_json_start = response_content.strip().startswith("```json")
    is_json_end = response_content.strip().endswith("```")
    if is_json_start and is_json_end:
        # Extract content between the first ```json and the last ```
        content = response_content.strip()
        start_index = content.find("```json") + len("```json")
        end_index = content.rfind("```")
        if start_index < end_index:
            extracted_content = content[start_index:end_index].strip()
            # Make sure we don't have trailing backticks in the extracted content
            if extracted_content.endswith("```"):
                extracted_content = extracted_content[:-3].strip()
            try:
                json.loads(extracted_content)
                return extracted_content
            except json.JSONDecodeError:
                pass

    # Check for JSON code block format with triple backticks
    json_block_patterns = ["```json\n", "```\n"]

    for pattern in json_block_patterns:
        if pattern in response_content and not is_marker_inside_json(response_content, pattern):
            start_index = response_content.find(pattern)
            content_after_marker = response_content[start_index + len(pattern) :]

            # Find the closing backticks that are not inside a JSON structure
            end_index = content_after_marker.find("```")  # Initial find

            while end_index != -1 and is_marker_inside_json(
                content_after_marker[: end_index + 3], "```"  # Check based on original slice
            ):
                # Search *after* the found marker in the original slice
                search_start = end_index + 3
                next_end = content_after_marker.find("```", search_start)
                if next_end == -1:
                    end_index = -1  # No more markers found
                    break
                end_index = next_end  # Update end_index to the new position

            if end_index != -1:
                extracted_content = content_after_marker[:end_index].strip()

                # Special handling for nested JSON with code blocks
                if "```json{" in extracted_content:
                    # Find the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            pass

                # If the content has trailing backticks or newlines (followed by
                # backticks), clean them up
                if "\n```" in extracted_content:
                    extracted_content = extracted_content.split("\n```")[0].strip()
                elif extracted_content.endswith("```"):
                    extracted_content = extracted_content[:-3].strip()

                # Try to parse the entire extracted content first
                try:
                    json.loads(extracted_content)
                    return extracted_content
                except json.JSONDecodeError:
                    # If that fails, look for the last complete JSON object
                    first_brace = extracted_content.find("{")
                    last_brace = extracted_content.rfind("}")

                    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
                        json_content = extracted_content[first_brace : last_brace + 1].strip()
                        # Remove any trailing backticks that aren't part of the JSON string
                        if json_content.endswith("```"):
                            json_content = json_content[:-3].strip()
                        try:
                            json.loads(json_content)
                            return json_content
                        except json.JSONDecodeError:
                            # If still not valid, return the extracted content as-is
                            pass

                # If we couldn't find valid JSON but have a clean content, return it
                return extracted_content

    # If no specific markers found, try to extract JSON object directly
    # Look for the first { and the last }
    first_brace = response_content.find("{")
    last_brace = response_content.rfind("}")

    if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
        extracted_json = response_content[first_brace : last_brace + 1].strip()
        try:
            json.loads(extracted_json)
            # Return the validated JSON if parsing succeeds
            return extracted_json
        except json.JSONDecodeError:
            # If not valid JSON, continue to the final return
            pass

    # Special case for the test with leading text and json code block
    if "```json\n" in response_content and "\n```" in response_content:
        # Get content between ```json\n and \n```
        start_idx = response_content.find("```json\n") + len("```json\n")
        end_idx = response_content.find("\n```", start_idx)
        if start_idx != -1 and end_idx != -1 and start_idx < end_idx:
            json_content = response_content[start_idx:end_idx].strip()
            if json_content.startswith("{") and json_content.endswith("}"):
                return json_content

    # If we couldn't extract valid JSON, return the original content
    return response_content.strip()


def is_marker_inside_json(text: str, marker: str) -> bool:
    """
    Check if a marker is inside a JSON structure by analyzing the string.

    Args:
        text (str): The text to analyze
        marker (str): The marker to check

    Returns:
        bool: True if the marker appears to be inside a JSON structure, False otherwise
    """
    marker_pos = text.find(marker)
    if marker_pos == -1:
        return False

    # Count opening and closing braces before the marker
    open_braces = text[:marker_pos].count("{")
    close_braces = text[:marker_pos].count("}")

    # If we have more opening braces than closing ones before the marker,
    # the marker is likely inside a JSON structure
    return open_braces > close_braces


# --- Environment Setup ---

logger = logging.getLogger(__name__)


def get_user_shell_path() -> str | None:
    """
    Retrieves the user's PATH environment variable as set by their default login shell.

    This is primarily useful on macOS and Linux where GUI applications might not
    inherit the full PATH set by shell configuration files (.zshrc, .bash_profile, etc.).
    On Windows, it typically returns None as the standard PATH is usually sufficient.

    Returns:
        str | None: The PATH string from the login shell, or None if unable to retrieve
                    or if running on Windows.
    """
    system = platform.system()
    if system == "Windows":
        logger.debug("Windows detected. Skipping login shell PATH retrieval.")
        return None
    elif system not in ("Darwin", "Linux"):
        logger.warning(f"Unsupported operating system for shell PATH retrieval: {system}")
        return None

    try:
        # Get the user's default shell
        shell_path = os.environ.get("SHELL")
        if not shell_path:
            # Attempt to find default shell if SHELL env var is not set
            if system == "Darwin":
                # On macOS, dscl can get the user's shell
                try:
                    user = os.getlogin()
                    result = subprocess.run(
                        ["dscl", ".", "-read", f"/Users/{user}", "UserShell"],
                        capture_output=True,
                        text=True,
                        check=True,
                    )
                    shell_path = result.stdout.split(":")[-1].strip()
                    if not shell_path or not os.path.exists(shell_path):
                        shell_path = "/bin/zsh"  # Fallback for macOS
                except (FileNotFoundError, subprocess.CalledProcessError, IndexError):
                    shell_path = "/bin/zsh"  # Fallback for macOS
            else:  # Linux
                shell_path = "/bin/bash"  # Common default on Linux

        logger.debug(f"Using shell: {shell_path}")

        # Command to echo the PATH from a login shell
        command = f'"{shell_path}" -ilc "echo $PATH"'  # -i for interactive, -l for login

        # Run the command using subprocess.run
        # Use shell=True carefully, only because the command structure is controlled
        result = subprocess.run(
            command,
            capture_output=True,
            text=True,
            check=True,
            shell=True,
            env=os.environ.copy(),  # Pass current environment
        )

        full_path = result.stdout.strip()
        if full_path:
            logger.debug(f"Successfully retrieved PATH from login shell: {full_path}")
            return full_path
        else:
            logger.warning("Login shell did not return a PATH.")
            return None
    except subprocess.CalledProcessError as e:
        logger.error(f"Failed to get PATH from login shell. Error: {e}")
        logger.error(f"Stderr: {e.stderr.strip()}")
        return None
    except FileNotFoundError:
        logger.error(f"Shell executable not found at: {shell_path}")
        return None
    except Exception as e:
        logger.error(f"An unexpected error occurred while getting shell PATH: {e}")
        return None


def setup_subprocess_environment():
    """
    Updates the current process's PATH environment variable with the one from the
    user's login shell, if necessary and possible.

    This helps ensure subprocesses launched by this application can find executables
    installed via package managers like Homebrew or in user-specific bin directories.
    """
    logger.info("Attempting to set up subprocess environment with login shell PATH...")

    original_path = os.environ.get("PATH", "")
    logger.debug(f"Initial PATH: {original_path}")

    # Only attempt to get shell path on non-Windows systems
    if platform.system() == "Windows":
        logger.info("Windows detected. Using default PATH for subprocesses.")
        return

    user_path = get_user_shell_path()

    if user_path and user_path != original_path:
        # Prepend the user path to the original path to prioritize user bins
        # while keeping system paths accessible. Use os.pathsep as the separator.
        # updated_path = f"{user_path}{os.pathsep}{original_path}"
        # Overwrite PATH entirely as the login shell PATH should be comprehensive
        updated_path = user_path
        logger.info(f"Updating os.environ['PATH'] to: {updated_path}")
        os.environ["PATH"] = updated_path
    elif user_path == original_path:
        logger.info("Login shell PATH is the same as the initial PATH. No update needed.")
    else:
        logger.warning(
            "Could not retrieve user login shell PATH. "
            "Subprocesses will use the initial PATH. "
            "User-installed executables might not be found."
        )
